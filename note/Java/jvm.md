## JVM

​	Java虚拟机是一个在真实计算机上模拟各种计算机功能来实现的一个虚拟计算机。Java虚拟机屏蔽了底层操作系统使得Java程序可以在实现了虚拟机的平台上不用修改就可以直接运行。

​	虚拟机在没有运行时就像是存储在计算机中的一个程序，运行时就是操作系统中的一个进程实例。虚拟机进程来读取“.Class“文件（类加载器子系统），并翻译成本机CPU能识别的指令，再在计算机上运行（执行引擎子系统），虚拟机也会自动释放没有用的对象（垃圾回收子系统）。

### 类的加载机制

#### 目的

- 将 .class文件二进制文件加载到内存中
- 将静态存储结构转化为方法区运行时数据结构
- 在堆中创建Class对象封装方法区中的类的数据结构，并提供访问接口

#### 过程

1. 加载

   有三层类加载器，加载完后数据就按虚拟机所需格式存在了方法区内，堆中也建立了Class对象

2. 验证

   文件格式验证，元数据验证，字节码验证，符号引用验证

3. 准备

   - 正式在方法区中分配内存==那之前没有分配内存吗==
   - 为静态变量分配内存并初始化为默认值
   - static final直接赋值

4. 解析

   符号引用转化为直接引用，常见的有类、接口、字段、类方法、接口方法，方法类型、方法句柄、调用限定符

5. 初始化

   - 类初始化<clinit>：静态赋值代码和静态代码块按顺序执行，先初始化父类
   - 在堆区分配实例对象需要的内存
   - 对所有实例变量赋默认值
   - 实例初始化<init>：赋值代码和代码块按顺序，再构造器，先初始化父类

#### 类加载器

- 大致分为三大类
  1. 启动类加载器bootstrap ClassLoader：JDK/jre/lib
  2. 扩展类加载器Ext ClassLoader：JDK/jre/lib/ext
  3. 应用类加载器AppClassLoader
- 全盘负责、父类委托、缓存
- 双亲委派
- 抽象类ClassLoader=》安全加载类=〉URL加载类，实现了findClass，=》Ext和App

#### 自定义类加载器

- 重写findClass方法不会破坏双亲委派，重写loadClass会
- 要调用difineClass方法

### jvm内存结构

#### 堆

- 通常分为新生代和老年代
- 存放对象实例和数组等
- 垃圾回收的主要区域，根据分代回收才细分为young，old，eden等等
- 分配有多个线程私有的分配缓冲区

#### 栈

- 程序计数器：线程私有的，每个线程都有一个
- JVM栈：Java方法被调用至完成就对应一个栈帧入栈到出栈，栈帧存储局部变量表、操作栈、动态链接、方法出口等信息
- 本地方法栈：服务于本地方法

#### 方法区

- 存储类的信息、静态变量、常量等数据
- 常量池属于方法区的一部分

#### 对象的生成、存储结构和访问

- new一个对象首先在常量池中查看是否能定位到一个类的符号引用
- 加载连接初始化，为新对象分配内存，用到了线程私有的缓冲区
- 内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。
- new指令后执行init方法后才真正创建完了一个对象
- 在HotSpot虚拟机中结构分为对象头、实例数据和填充
- 对象头(Header)：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。
- 访问分为句柄访问和直接指针访问，句柄在垃圾回收时jvm栈中内容不会变，直接访问更快，少了一次指针寻址

#### 图解

![img](jvm.assets/1728de07f0a8ea3c)

![img](jvm.assets/1728de0bcde73307)





### 垃圾回收

- 引用计数法：不能解决循环引用
- 可达性分析法
- 可作为GC Roots的对象有四种
- 四种引用强度：强，软，弱，虚

#### 回收策略

1. 标记——清除
   - 碎片多，效率不高
2. 复制算法：针对新生代
   - 减少了内存的可用容量，空间利用率低
   - 不会有碎片
   - 8:1:1，多出来的直接进入老年代
3. 标记——整理：针对老年代
   - 存活移到另一边，不会有碎片
4. 分代回收

#### 回收器

1. Serial和Serial Old

   - 单线程的，串行的，运行时要暂停其他工作线程
   - 新生代复制，老年代整理

2. ParNew

   - 新生代的，并行的复制算法，也会暂停

3. Parallel Scavenger和Parallel Old

   - 关注的是吞吐量
   - 新生代并行复制
   - 老年代并行整理

4. CMS

   - 目标是获得最短回收停顿时间，老年代，清除算法
   - 有空间碎片

   1. 初始标记：串行，暂停
   2. 并发标记：root tracing，并发，不停
   3. 重新标记：并发，暂停
   4. 并发清除：并发，不停
   5. （并发重置线程）

5. G1

   - 面向服务端的垃圾回收器
   - 并行与并发，分代收集，但是各代没有物理隔阂
   - 空间整合：整理算法
   - 可预测停顿

   1. 初始标记：串行，停顿
   2. root reign scan
   3. 并发标记：并发，不停，如果一个区域内都不要回收则整个区域立即回收
   4. remark：并发，停
   5. 回收：并发，停

#### 内存分配策略

1. 优先在Eden，如果有分配缓冲区则在缓冲区
2. 大对象和长期存活对象进入老年代
3. 动态对象年龄判断
4. 空间分配担保