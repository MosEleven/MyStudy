## 1、删除排序数组中的重复项

- 双指针

## 2、买卖股票的最佳时机

- 类加正数

## 3、旋转数组

- 一次转一格
- ==reverse三次==
- 一次转n格

## 4、是否存在重复元素

- 用set
- ==如果限定范围0-n-1，新的解法，利用数组下标作为记号==

## 5、只出现一次的数字

- 异或

## 6、两个数组的交集

- 排序再做
- hashmap存放数量少的数组

## 7、加一

- 判断要不要进位就行

## 8、移动零

- 双指针

## 9、两数之和

- map

## 10、有效数独

- 27个set

## 11、旋转图像

- 转置再对称
- 一圈一圈转

## 12、反转字符串

- 双指针

## 13、整数反转

- 可以在乘以10之前判断乘加后是否会溢出

## 14、字符串中的第一个唯一字符

- 两遍hashmap

## 15、有效的字母异位词

- s.toCharArray-->Array.sort-->Array.equal
- Hash map

## 16、验证回文字符串

- Character.isLetterOrDigit-->Character.toLowerCase

## 17、字符串转换整数

- 判断完第一个字符后再进入循环
- ans > (Integer.MAX_VALUE - digit) / 10 判断溢出
- return negative? Integer.MIN_VALUE : Integer.MAX_VALUE; 判断返回值

## 18、实现 strStr()【🌟】

- indexOf==substring( ).equals( )
- 滚动哈希（使用26进制）
- KMP

## 19、外观数列

- ==在频繁操作字符串时明显用StringBuffer会快很多；==

## 20、最长公共前缀

- 横向比较：俩俩比较更新前缀
- 纵向比较：所有的第i个都相同则前进一格
- 分治和二分不太有用的感觉

## 21、删除链表中的节点

- 憨憨题目，就node.val = node.next.val; node.next = node.next.next;

## 22、删除链表的倒数第N个节点

- 先快指针移动n次，如果为空则返回head.next

## 23、反转链表

- 迭代：指向上一个node
- 递归：要注意最后节点指向null
- ==head.next.next = head;==

## 24、合并两个有序链表

- 新造一个头节点简洁很多

## 25、回文链表

- 复制到List然后用双指针
- 反转

## 26、 环形链表

- 快慢指针
- 哈希表

## 27、二叉树的最大深度

- 递归

## 28、验证二叉搜索树

- 递归
- ==中序遍历==

## 29、对称二叉树

- 迭代：要用Queue
- 同时对比两个节点

## 30、二叉树的层序遍历

- 用Queue迭代，一层层输出

## 31、将有序数组转换为二叉搜索树

- 递归，每次生成一个节点，然后递归生成左右子树

## 32、合并两个有序数组

- 从后往前插入

## 33、第一个错误的版本

- 为了防止加法溢出，int mid = lo + (hi - lo) / 2;

## 34、爬楼梯

- 斐波那契，迭代
- 矩阵快速幂运算
- 推导公式

## 35、买卖股票的最佳时机

- 只能买卖一次
- 比较最小值和最大利润就行了

## 36、最大子序和

- 如果是负数，就保留一个最大的负数
- 正数就累加起来

## 37、打家劫舍

- 动态规划得出状态转移方程
- 再进行迭代

## 38、打乱数组

- 洗牌算法；

## 39、最小栈

- 主要是怎么实现取出最小值
- 最小值也要存放在一个栈里面

## 40、Fizz Buzz

- 简单

## 41、计数质数

- Sieve of Eratosthenes

## 42、3的幂

- Integer.toString(number, base)
- ==Integer.toString(n, 3).matches("^10*$");==

## 43、罗马数字转整数

- 当前数比上一个小就改为减法

## 44、位1的个数

- 有个很简洁的方法

## 45、汉明距离

- 异或再1的个数
- Integer.**bitCount**(x ^ y);

## 46、颠倒二进制位

- 就那样做

## 47、帕斯卡三角形

- 每层读取上一层的串，来构造本层

## 48、有效的括号

- 用stack来做

## 49、缺失的数字

- 总数再减掉数组里面的数

## 50、打家劫舍III【🌟】

- 递归，分为抢和不抢两种情况，返回最大值
- 直接在本节点计算两种情况，会减少很多次递归

## 2、两数相加

- 注意是从第一个节点是个位

